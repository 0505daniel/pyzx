\documentclass[a4paper,11pt]{article}\linespread{1.1}\usepackage[top=3cm, bottom=2.54cm, left=2.54cm, right=2.54cm]{geometry}\usepackage[utf8]{inputenc}\usepackage[english]{babel}\usepackage{amsmath}\usepackage{amsfonts}\usepackage{amssymb}\usepackage{graphicx}\usepackage{hyperref}\begin{document}\pagenumbering{gobble}\Large \begin{center}T-count optimization in quantum circuits using graph-theoretical rewriting of ZX-diagrams\\ \hspace{10pt}\normalsize% Author names and affiliationsAleks Kissinger $^1$, John van de Wetering $^1$ \\\hspace{10pt}\small  $^1$ Radboud University Nijmegen, The Netherlands\end{center}\hspace{10pt}\normalsize\noindentMost fault-tolerant architectures for quantum computers allow fast execution of Clifford gates. In order for the computation to be universal, it most however also execute some instruction outside of the Clifford set. This instruction is usally taken to be the \emph{T-gate} and the prevailing way to implement it, is to use magic states that have to be distilled to the required fidelity. This is very resource intensive. It is therefore desirable to find optimizations of circuits where the `T-count', the amount of T-gates, is as low as possible. The field of T-count optimization has been quite active in the recent years. Some approaches synthesize provably optimal circuits, but these run in exponential time and only work for small circuits *citations*. Besides these algorithms there are a variety of efficient heuristic algorithms. There are for instance methods that optimize CNOT+T subcircuits using the \emph{phase-polynomial} formalism like \emph{T-par} \cite{amy2014polynomial}. This method can be made more efficient by preprocessing the hadamard gates by optimizing them \cite{abdessaied2014quantum} or `gadgetizing' them into ancillae qubits \cite{heyfron2018efficient}. A recent paper used this formalism in combination with a variety of peephole optimizations to achieve state-of-the-art results \cite{nam2018automated}.Our approach to optimization takes a wildly different approach. We translate quantum circuits into \emph{ZX-diagrams}. These diagrams are like tensor network graphs consisting of non-unitary generators called Z- and X-\emph{spiders}. These graphs come with a set of rewrite rules known as the \emph{ZX-calculus}. It has been shown that the ZX-calculus is complete for Clifford-circuits, meaning that two Clifford circuits are equal if and only if one can be rewritten into the other by the rules of the ZX-calculus \cite{backens2016simplified}. There are also various known additional rewrite rules that make the calculus complete for Clifford+T circuits \cite{jeandel2018complete}. We use a specific set of rewrite rules based on the graph-theoretic notions of \emph{local complementation} and \emph{pivoting} that always terminate in finite time, in addition to a procedure called \emph{gadgetization} that rewrites T-gates into a form more amenable to simplification. The result is a ZX-graph with a T-count that in most cases matches, and in some cases surpasses the best known state-of-the-art T-count (in one particular case we achieve a T-count equal to 50\% of the previous best-known, while in another case we are the first general-purpose method to achieve the theoretical lower-bound of that circuit). The graph produced by our rewrites is not circuit-like. We use techniques based on the notion of \emph{cut-rank} to cut our graph into pieces that do resemble a circuit, and in this way we can extract a circuit from the ZX-graph. The resulting circuit is not optimized for general gate-count, but post-processing with some trivial circuit identities followed by phase-polynomial optimization gives competitive values for CNOT-count and Hadamard-count.If this abstract is accepted, we would present the theory behind our simplification strategy, and we would give a demonstration of the open source Python library in which we have implemented it: \emph{PyZX}. The reader is invited to watch our short demonstration video about PyZX included with the abstract.\bibliographystyle{plain}\bibliography{bibliography}\end{document}